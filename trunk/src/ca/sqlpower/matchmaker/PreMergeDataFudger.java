/*
 * Copyright (c) 2007, SQL Power Group Inc.
 *
 * This file is part of Power*MatchMaker.
 *
 * Power*MatchMaker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Power*MatchMaker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
 */

package ca.sqlpower.matchmaker;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.apache.log4j.Logger;

import ca.sqlpower.architect.ArchitectException;
import ca.sqlpower.matchmaker.PotentialMatchRecord.MatchType;
import ca.sqlpower.matchmaker.graph.BreadthFirstSearch;
import ca.sqlpower.matchmaker.graph.GraphConsideringOnlyGivenNodes;
import ca.sqlpower.matchmaker.graph.GraphModel;
import ca.sqlpower.matchmaker.graph.NonDirectedUserValidatedMatchPoolGraphModel;

/**
 * This class is used to create entries in the result table for merging using
 * the C engine. Once the merging has been implemented in java this should never
 * be used.
 */
public class PreMergeDataFudger {
	
	Logger logger = Logger.getLogger(PreMergeDataFudger.class);
	
	/**
	 * The name of the rule set that all fudged edges will belong to.
	 * The constructor finds or creates a rule set of this name for
	 * the pool's match object.
	 */
	public static final String FUDGE_RULE_SET_NAME = "Fudge_For_Merge";
	
	/**
	 * This is the pool that we will be fudging.
	 */
	private final MatchPool pool;
	
	/**
	 * The session that we are working on
	 */
	private final MatchMakerSession session;
	
	/**
	 * The match ruleset that all matches generated by this fudger belong to.
	 */
	private final MatchRuleSet ruleSet;
	
	
	/**
	 * Creates a new data fudger for the given match pool. The purpose of the
	 * fugder is to arrange the match pool so that it meets the simplistic
	 * requirements of the merge engine.  When the merge engine is reimplemented
	 * in Java, we won't need this fugder any more.
	 * <p>
	 * This constructor will add a match ruleset to the pool's match.  That ruleset
	 * will own all fudged edges this fugder creates.  This makes unfugding easier:
	 * simply remove all edges belonging to that ruleset.
	 */
	public PreMergeDataFudger(MatchMakerSession session, MatchPool pool) {
		this.session = session;
		this.pool = pool;
		
		Match match = pool.getMatch();
		MatchRuleSet fudgeRuleSet = match.getMatchCriteriaGroupByName(FUDGE_RULE_SET_NAME);
		if (fudgeRuleSet == null) {
			fudgeRuleSet = new MatchRuleSet();
			fudgeRuleSet.setName(FUDGE_RULE_SET_NAME);
			match.addMatchCriteriaGroup(fudgeRuleSet);
		}
		ruleSet = fudgeRuleSet;
	}
	
	/**
	 * This method creates entries in the result table for merging using the C
	 * engine. Once the merging has been implemented in java this should never
	 * be used.
	 */
	public void fudge() throws SQLException {
		for (SourceTableRecord str : pool.getSourceTableRecords()) {
			GraphModel<SourceTableRecord, PotentialMatchRecord> nonDirectedGraph =
	    		new NonDirectedUserValidatedMatchPoolGraphModel(pool, new HashSet<PotentialMatchRecord>());
	    	BreadthFirstSearch<SourceTableRecord, PotentialMatchRecord> bfs =
	            new BreadthFirstSearch<SourceTableRecord, PotentialMatchRecord>();
	        Set<SourceTableRecord> reachable = new HashSet<SourceTableRecord>(bfs.performSearch(nonDirectedGraph, str));

	        GraphModel<SourceTableRecord, PotentialMatchRecord> considerGivenNodesGraph =
	        	new GraphConsideringOnlyGivenNodes(pool, reachable);
	        logger.debug("Graph contains " + considerGivenNodesGraph.getNodes() + " nodes.");

	        logger.debug("Find the ultimate master");
	        SourceTableRecord ultimateMaster = pool.findUltimateMaster(considerGivenNodesGraph,
					str, new ArrayList<SourceTableRecord>());
	        if (str == ultimateMaster) continue;
	        PotentialMatchRecord pmr = new PotentialMatchRecord(ruleSet, MatchType.UNMATCH, str, ultimateMaster, false);
	        pool.addPotentialMatch(pmr);
	        pmr.setMaster(ultimateMaster);
		}
	}
	
	/**
	 * removes the fudge from the database.
	 */
	public void unfudge() throws SQLException, ArchitectException {
		for (int i = pool.getPotentialMatches().size() - 1; i >= 0; i--) {
			PotentialMatchRecord pmr = (PotentialMatchRecord) pool.getPotentialMatches().toArray()[i];
			if (pmr.getCriteriaGroup() == ruleSet) {
				pool.removePotentialMatch(pmr);
			}
		}
	}
	
	/**
	 * Returns the ruleset that owns all potential match records created as a result
	 * of the fugde operation.
	 * 
	 * @return
	 */
	public MatchRuleSet getRuleSet() {
		return ruleSet;
	}
}
