/*
 * Copyright (c) 2007, SQL Power Group Inc.
 *
 * This file is part of Power*MatchMaker.
 *
 * Power*MatchMaker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Power*MatchMaker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
 */

package ca.sqlpower.matchmaker;

import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.apache.log4j.Logger;

import ca.sqlpower.architect.ArchitectException;
import ca.sqlpower.architect.ddl.DDLUtils;
import ca.sqlpower.graph.BreadthFirstSearch;
import ca.sqlpower.graph.GraphModel;
import ca.sqlpower.matchmaker.PotentialMatchRecord.MatchType;
import ca.sqlpower.matchmaker.graph.GraphConsideringOnlyGivenNodes;
import ca.sqlpower.matchmaker.graph.NonDirectedUserValidatedMatchPoolGraphModel;
import ca.sqlpower.matchmaker.munge.MungeProcess;

/**
 * This class is used to create entries in the result table for merging using
 * the C engine. Once the merging has been implemented in java this should never
 * be used.
 */
public class PreMergeDataFudger {
	
	Logger logger = Logger.getLogger(PreMergeDataFudger.class);
	
	/**
	 * The name of the munge process that all fudged edges will belong to.
	 * The constructor finds or creates a rule set of this name for
	 * the pool's project object.
	 */
	public static final String FUDGE_MUNGE_PROCESS_NAME = "Fudge_For_Merge";
	
	/**
	 * This is the pool that we will be fudging.
	 */
	private final MatchPool pool;
	
	/**
	 * The session that we are working on
	 */
	private final MatchMakerSession session;
	
	/**
	 * The munge process that all matches generated by this fudger belong to.
	 */
	private final MungeProcess mungeProcess;
	
	
	/**
	 * Creates a new data fudger for the given match pool. The purpose of the
	 * fugder is to arrange the match pool so that it meets the simplistic
	 * requirements of the merge engine.  When the merge engine is reimplemented
	 * in Java, we won't need this fugder any more.
	 * <p>
	 * This constructor will add a munge process to the pool's match.  That ruleset
	 * will own all fudged edges this fugder creates.  This makes unfugding easier:
	 * simply remove all edges belonging to that ruleset.
	 */
	public PreMergeDataFudger(MatchMakerSession session, MatchPool pool) {
		this.session = session;
		this.pool = pool;
		
		Project project = pool.getProject();
		MungeProcess fudgeMungeProcess = project.getMungeProcessByName(FUDGE_MUNGE_PROCESS_NAME);
		if (fudgeMungeProcess == null) {
			fudgeMungeProcess = new MungeProcess();
			fudgeMungeProcess.setName(FUDGE_MUNGE_PROCESS_NAME);
			project.getMungeProcessesFolder().addChild(fudgeMungeProcess);
			session.getDAO(Project.class).save(project);
		}
		mungeProcess = fudgeMungeProcess;
	}
	
	/**
	 * This method creates entries in the result table for merging using the C
	 * engine. Once the merging has been implemented in java this should never
	 * be used.
	 * <p>
	 * WARNING: The Match pool will not be in a consistent state after calling
	 * this method. If you wish to use the Match pool after calling this fudge
	 * method, you should call the {@link MatchPool#findAll(java.util.List)}
	 */
	public void fudge() throws SQLException {
		for (SourceTableRecord str : pool.getSourceTableRecords()) {
			GraphModel<SourceTableRecord, PotentialMatchRecord> nonDirectedGraph =
	    		new NonDirectedUserValidatedMatchPoolGraphModel(pool, new HashSet<PotentialMatchRecord>());
	    	BreadthFirstSearch<SourceTableRecord, PotentialMatchRecord> bfs =
	            new BreadthFirstSearch<SourceTableRecord, PotentialMatchRecord>();
	        Set<SourceTableRecord> reachable = new HashSet<SourceTableRecord>(bfs.performSearch(nonDirectedGraph, str));

	        GraphModel<SourceTableRecord, PotentialMatchRecord> considerGivenNodesGraph =
	        	new GraphConsideringOnlyGivenNodes(pool, reachable);
	        logger.debug("Graph contains " + considerGivenNodesGraph.getNodes() + " nodes.");

	        logger.debug("Find the ultimate master");
	        SourceTableRecord ultimateMaster = pool.findUltimateMaster(considerGivenNodesGraph,
					str, new ArrayList<SourceTableRecord>());
	        if (str == ultimateMaster) continue;
	        PotentialMatchRecord pmr = new PotentialMatchRecord(mungeProcess, MatchType.UNMATCH, str, ultimateMaster, false);
	        pool.addPotentialMatch(pmr);
	        pmr.setMaster(ultimateMaster);
		}
		pool.store();
		
		Statement stmt = null;
		
		try {
			stmt = session.getConnection().createStatement();
			stmt.executeUpdate("update " + 
								DDLUtils.toQualifiedName(pool.getProject().getResultTable()) +
								"\n set dup1_master_ind='Y'," +
								"\n dup_candidate_10=dup_candidate_20," +
								"\n dup_candidate_20=dup_candidate_10," +
								"\n current_candidate_10=current_candidate_20,"+
								"\n current_candidate_20=current_candidate_10" +
								"\n where dup1_master_ind='N'");
		} finally {
			stmt.close();
		}
	}
	
	/**
	 * removes the fudge from the database.
	 */
	public void unfudge() throws SQLException, ArchitectException {
		for (int i = pool.getPotentialMatches().size() - 1; i >= 0; i--) {
			PotentialMatchRecord pmr = (PotentialMatchRecord) pool.getPotentialMatches().toArray()[i];
			if (pmr.getMungeProcess() == mungeProcess) {
				pool.removePotentialMatch(pmr);
			}
		}
	}
	
	/**
	 * Returns the ruleset that owns all potential match records created as a result
	 * of the fugde operation.
	 * 
	 * @return
	 */
	public MungeProcess getMungeProcess() {
		return mungeProcess;
	}
}
